#!/usr/bin/env bash

# Configuration
dotrun_PREFIX="${dotrun_PREFIX:-$HOME/.dotrun}"
BIN_DIR="$dotrun_PREFIX/bin"
DOC_TOKEN="### DOC"
EDITOR="${EDITOR:-nano}"

mkdir -p "$BIN_DIR"

# Color functions
color_folder() {
  local level=$1
  case $level in
  0) echo -e "\033[1;34m" ;; # Bright Blue
  1) echo -e "\033[1;36m" ;; # Bright Cyan
  2) echo -e "\033[1;35m" ;; # Bright Magenta
  *) echo -e "\033[1;33m" ;; # Bright Yellow
  esac
}
color_script="\033[1;92m" # Bright Green
color_doc="\033[0;37m"    # Gray
color_reset="\033[0m"
# Functions

# Traverse bin directory and print scripts with doc in tree-style and colors
# list_scripts show_docs scope
#   show_docs: 0 = names only, 1 = include docs
#   scope:     optional sub-folder (e.g. "code/")
list_scripts() {
  local show_docs="$1"
  local scope="$2"
  local start_dir="$BIN_DIR/${scope%/}" # strip trailing /

  [[ ! -d "$start_dir" ]] && {
    echo "No such folder: $scope"
    return 1
  }

  declare -A printed_folders=()

  _print_folder_chain() {
    local path="$1" indent=""
    [[ "$path" == "." || -z "$path" ]] && return
    local current=""
    IFS='/' read -ra parts <<<"$path"
    for part in "${parts[@]}"; do
      current="${current:+$current/}$part"
      if [[ -z "${printed_folders[$current]+x}" ]]; then
        echo -e "${indent}\033[1;33mðŸ“‚ $part${color_reset}"
        printed_folders["$current"]=1
      fi
      indent+="  "
    done
  }

  while IFS= read -r -d '' file; do
    rel_path="${file#$BIN_DIR/}"
    script_name="$(basename "$rel_path" .sh)"
    folder_path="$(dirname "$rel_path")"

    _print_folder_chain "$folder_path"

    # indent scripts one level deeper than their folder depth
    local depth=0 indent=""
    [[ "$folder_path" != "." ]] && depth=$(awk -F'/' '{print NF}' <<<"$folder_path")
    for ((i = 0; i < depth; i++)); do indent+="  "; done

    echo -e "${indent}${color_script}${script_name}${color_reset}"
    if ((show_docs)); then
      awk "/^$DOC_TOKEN/ { p = !p; next } p { print \"${indent}  ${color_doc}\" \$0 \"$color_reset\" }" "$file"
    fi
  done < <(find "$start_dir" -type f -name "*.sh" -print0 | sort -z)
}

# Create script skeleton
create_script_skeleton() {
  local name="$1"
  local file="$BIN_DIR/$name.sh"
  mkdir -p "$(dirname "$file")"
  cat >"$file" <<EOF
#!/usr/bin/env bash
$DOC_TOKEN
# $(basename "$name") - describe what this script does
$DOC_TOKEN
set -euo pipefail

#SCRIPT_DIR="\$(cd "\$(dirname "\${BASH_SOURCE[0]}")" && pwd)"
#source "\$SCRIPT_DIR/../helpers/myfile.sh"

main() {
  echo "Running $(basename "$name")..."
}

main "\$@"
EOF
  chmod +x "$file"
}

# Search script by name regardless of path
find_script_file() {
  local name="$1"
  find "$BIN_DIR" -type f -name "$(basename "$name").sh" | head -n 1
}

new_script() {
  local name="$1"
  local file="$BIN_DIR/$name.sh"
  if [[ -e "$file" ]]; then
    echo "Script '$name' already exists at $file"
    exit 1
  fi
  create_script_skeleton "$name"
  echo "Created new script: $file"
}

add_script() {
  local name="$1"
  local file="$BIN_DIR/$name.sh"
  if [[ ! -f "$file" ]]; then
    create_script_skeleton "$name"
    echo "Created new script: $file"
  fi
  "$EDITOR" "$file"
}

edit_script() {
  local file
  file=$(find_script_file "$1")
  if [[ -n "$file" ]]; then
    "$EDITOR" "$file"
  else
    echo "Script '$1' not found"
    exit 1
  fi
}

edit_docs() {
  local file
  file=$(find_script_file "$1")
  if [[ -n "$file" ]]; then
    "$EDITOR" "$file"
  else
    echo "Script '$1' not found"
    exit 1
  fi
}

show_help() {
  local file
  file=$(find_script_file "$1")
  if [[ -z "$file" ]]; then
    echo "Script '$1' not found"
    exit 1
  fi
  awk "/^$DOC_TOKEN/ { p = !p; next } p" "$file"
}

run_script() {
  local name="$1"
  shift
  local file
  file=$(find_script_file "$name")
  if [[ -z "$file" ]]; then
    echo "Script '$name' not found"
    exit 1
  fi
  "$file" "$@"
}

# Main command parser
case "$1" in
-l | -L)
  show_docs=0
  [[ "$1" == "-L" ]] && show_docs=1
  scope="${2:-}" # optional second arg
  list_scripts "$show_docs" "$scope"
  ;;
new)
  [[ -z "$2" ]] && {
    echo "Usage: drun new <name>"
    exit 1
  }
  new_script "$2"
  ;;
add)
  [[ -z "$2" ]] && {
    echo "Usage: drun add <name>"
    exit 1
  }
  add_script "$2"
  ;;
edit)
  [[ -z "$2" ]] && {
    echo "Usage: drun edit <name>"
    exit 1
  }
  edit_script "$2"
  ;;
edit:docs)
  [[ -z "$2" ]] && {
    echo "Usage: drun edit:docs <name>"
    exit 1
  }
  edit_docs "$2"
  ;;
help)
  [[ -z "$2" ]] && {
    echo "Usage: drun help <name>"
    exit 1
  }
  show_help "$2"
  ;;
"" | -h | --help)
  echo "drun <command> [args...]"
  echo
  echo "Commands"
  echo "  -l                  List all scripts (names only)"
  echo "  -L                  List scripts with docs, optionally scoped"
  echo "  -l/L [folder/]      List scripts within the scoped folder"
  echo "  list                List all managed scripts in tree format"
  echo "  new <name>          Create <name>.sh skeleton in \$BIN_DIR"
  echo "  add <name>          Create and open <name>.sh in editor"
  echo "  edit <name>         Open existing script in editor"
  echo "  edit:docs <name>    Open script at docs section"
  echo "  help <name>         Show embedded docs for <name>"
  echo "  <name> [argsâ€¦]      Execute script <name> from anywhere"
  echo
  echo "Env"
  echo "  dotrun_PREFIX    Override root (default \$HOME/.dotrun)"
  echo "  EDITOR              Command to open editor (default: nano)"
  exit 0
  ;;
*)
  if [[ -n "$1" ]]; then
    run_script "$@"
  else
    echo "Unknown command: $1"
    exit 1
  fi
  ;;
esac
