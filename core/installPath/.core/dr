#!/usr/bin/env bash

# shellcheck disable=SC2155
# shellcheck disable=SC1091
# shellcheck disable=SC2016
# Strict error handling
set -euo pipefail

IFS=$'\n\t'

# Version
DRUN_VERSION="1.0.1"

# Configuration
DR_CONFIG="${DR_CONFIG:-$HOME/.config/dotrun}"
BIN_DIR="$DR_CONFIG/bin"
DOC_TOKEN="### DOC"
_default_editor="$(command -v code >/dev/null && echo "code" || echo "nano")"
EDITOR="${EDITOR:-$_default_editor}"

# Validate EDITOR environment variable
if [[ -n "$EDITOR" ]] && ! command -v "$EDITOR" >/dev/null 2>&1; then
  echo "Warning: EDITOR '$EDITOR' not found in PATH, falling back to $_default_editor" >&2
  EDITOR="$_default_editor"
fi

mkdir -p "$BIN_DIR"

# Color functions
color_folder() {
  local level=$1
  case $level in
  0) echo -e "\033[1;34m" ;; # Bright Blue
  1) echo -e "\033[1;36m" ;; # Bright Cyan
  2) echo -e "\033[1;35m" ;; # Bright Magenta
  *) echo -e "\033[1;33m" ;; # Bright Yellow
  esac
}
color_script="\033[1;92m" # Bright Green
color_doc="\033[0;37m"    # Gray
color_reset="\033[0m"

# Input validation
validate_script_name() {
  local name="$1"
  if [[ -z "$name" ]]; then
    echo "Error: Script name cannot be empty" >&2
    return 1
  fi
  if [[ "$name" =~ [^a-zA-Z0-9_/-] ]]; then
    echo "Error: Script name contains invalid characters. Use only alphanumeric, underscore, dash, and forward slash." >&2
    return 1
  fi
}

# Check if required directories exist and are writable
check_prerequisites() {
  if [[ ! -d "$BIN_DIR" ]] && ! mkdir -p "$BIN_DIR" 2>/dev/null; then
    echo "Error: Cannot create or access BIN_DIR: $BIN_DIR" >&2
    exit 1
  fi
}

# Helpers
LINT_HELPER="$DR_CONFIG/helpers/lint.sh"
ALIASES_HELPER="$DR_CONFIG/helpers/aliases.sh"
CONFIG_HELPER="$DR_CONFIG/helpers/config.sh"
COLLECTIONS_HELPER="$DR_CONFIG/helpers/collections.sh"
# shellcheck disable=SC1090
[[ -f "$LINT_HELPER" ]] && source "$LINT_HELPER"
# shellcheck disable=SC1090
[[ -f "$ALIASES_HELPER" ]] && source "$ALIASES_HELPER"
# shellcheck disable=SC1090
[[ -f "$CONFIG_HELPER" ]] && source "$CONFIG_HELPER"
# shellcheck disable=SC1090
[[ -f "$COLLECTIONS_HELPER" ]] && source "$COLLECTIONS_HELPER"

# Traverse bin directory and print scripts with doc in tree-style and colors
# list_scripts show_docs scope
#   show_docs: 0 = names only, 1 = include docs
#   scope:     optional sub-folder (e.g. "code/")
list_scripts() {
  local show_docs="$1"
  local scope="$2"
  local start_dir="$BIN_DIR/${scope%/}" # strip trailing /

  [[ ! -d "$start_dir" ]] && {
    echo "Error: No such folder: $scope" >&2
    return 1
  }

  # Check for circular symlinks in the directory
  if find "$start_dir" -type l -exec test ! -e {} \; -print 2>/dev/null | grep -q .; then
    echo "Warning: Broken symlinks found in $start_dir" >&2
  fi

  declare -A printed_folders=()

  _print_folder_chain() {
    local path="$1" indent=""
    [[ "$path" == "." || -z "$path" ]] && return
    local current=""
    IFS='/' read -ra parts <<<"$path"
    for part in "${parts[@]}"; do
      current="${current:+$current/}$part"
      if [[ -z "${printed_folders[$current]+x}" ]]; then
        echo -e "${indent}\033[1;33mðŸ“‚ $part${color_reset}"
        printed_folders["$current"]=1
      fi
      indent+="  "
    done
  }

  while IFS= read -r -d '' file; do
    # shellcheck disable=SC2295
    rel_path="${file#"$BIN_DIR"/}"
    script_name="$(basename "$rel_path" .sh)"
    folder_path="$(dirname "$rel_path")"

    _print_folder_chain "$folder_path"

    # indent scripts one level deeper than their folder depth
    local depth=0 indent=""
    [[ "$folder_path" != "." ]] && depth=$(awk -F'/' '{print NF}' <<<"$folder_path")
    for ((i = 0; i < depth; i++)); do indent+="  "; done

    echo -e "${indent}${color_script}${script_name}${color_reset}"
    if ((show_docs)); then
      awk "/^$DOC_TOKEN/ { p = !p; next } p { print \"${indent}  ${color_doc}\" \$0 \"$color_reset\" }" "$file"
    fi
  done < <(find "$start_dir" -type f -name "*.sh" -print0 | sort -z)
}

# Create script skeleton
create_script_skeleton() {
  local name="$1"
  local file="$BIN_DIR/$name.sh"
  mkdir -p "$(dirname "$file")"

  # Create script file with skeleton
  local script_basename="$(basename "$name")"
  cat >"$file" <<EOF
#!/usr/bin/env bash
$DOC_TOKEN
# $script_basename - describe what this script does
$DOC_TOKEN
set -euo pipefail

# source "$DR_CONFIG/helpers/pkg.sh"

main() {
  echo "Running $script_basename..."
}

main "\$@"
EOF
  chmod +x "$file"
}

# Search script by name regardless of path
find_script_file() {
  local query="$1"

  # 1) explicit sub-folder path?
  if [[ "$query" == */* ]]; then
    local exact="$BIN_DIR/$query.sh"
    if [[ -f "$exact" ]]; then
      # Check if file is executable
      if [[ ! -x "$exact" ]]; then
        echo "Error: Script '$exact' is not executable" >&2
        return 1
      fi
      # Check for circular symlinks
      if [[ -L "$exact" ]] && ! readlink -e "$exact" >/dev/null 2>&1; then
        echo "Error: Script '$exact' is a broken symlink" >&2
        return 1
      fi
      echo "$exact"
      return
    fi
  fi

  # 2) fallback: search anywhere for basename
  local base
  base="$(basename "$query").sh"
  local found_file
  found_file=$(find "$BIN_DIR" -type f -name "$base" 2>/dev/null | head -n 1)

  if [[ -n "$found_file" ]]; then
    # Check if file is executable
    if [[ ! -x "$found_file" ]]; then
      echo "Error: Script '$found_file' is not executable" >&2
      return 1
    fi
    # Check for circular symlinks
    if [[ -L "$found_file" ]] && ! readlink -e "$found_file" >/dev/null 2>&1; then
      echo "Error: Script '$found_file' is a broken symlink" >&2
      return 1
    fi
    echo "$found_file"
  fi
}

add_script() {
  local name="$1"
  validate_script_name "$name" || exit 1
  check_prerequisites

  local file="$BIN_DIR/$name.sh"
  if [[ ! -f "$file" ]]; then
    create_script_skeleton "$name"
    echo "Created new script: $file"
  fi

  # Validate editor before using
  if [[ -z "$EDITOR" ]] || ! command -v "$EDITOR" >/dev/null 2>&1; then
    echo "Error: No valid editor found. Please set EDITOR environment variable." >&2
    exit 1
  fi

  "$EDITOR" "$file"
  [[ $(type -t run_shell_lint) == "function" ]] && run_shell_lint "$file"
}

edit_script() {
  local file
  file=$(find_script_file "$1")
  if [[ -n "$file" ]]; then
    # Validate editor before using
    if [[ -z "$EDITOR" ]] || ! command -v "$EDITOR" >/dev/null 2>&1; then
      echo "Error: No valid editor found. Please set EDITOR environment variable." >&2
      exit 1
    fi

    "$EDITOR" "$file"
    [[ $(type -t run_shell_lint) == "function" ]] && run_shell_lint "$file"
  else
    echo "Error: Script '$1' not found" >&2
    echo "Use 'dr -l' to list available scripts" >&2
    exit 1
  fi
}

show_help() {
  local file
  file=$(find_script_file "$1")
  if [[ -z "$file" ]]; then
    echo "Error: Script '$1' not found" >&2
    exit 1
  fi
  awk "/^$DOC_TOKEN/ { p = !p; next } p" "$file"
}

# Move/rename a script
move_script() {
  local source="$1"
  local destination="$2"
  
  # Validate inputs
  validate_script_name "$source" || exit 1
  validate_script_name "$destination" || exit 1
  
  # Find source script file
  local source_file
  source_file=$(find_script_file "$source")
  if [[ -z "$source_file" ]]; then
    echo "Error: Source script '$source' not found" >&2
    echo "Use 'dr -l' to list available scripts" >&2
    exit 1
  fi
  
  # Get relative paths
  local source_rel="${source_file#"$BIN_DIR"/}"
  local source_name="$(basename "$source_rel" .sh)"
  local source_dir="$(dirname "$source_rel")"
  
  # Construct destination paths
  local dest_file="$BIN_DIR/$destination.sh"
  local dest_name="$(basename "$destination")"
  local dest_dir="$(dirname "$destination")"
  
  # Normalize directory paths
  [[ "$source_dir" == "." ]] && source_dir=""
  [[ "$dest_dir" == "." ]] && dest_dir=""
  
  # Check if destination already exists
  if [[ -f "$dest_file" ]]; then
    echo "Error: Destination script '$destination' already exists" >&2
    exit 1
  fi
  
  # Check for circular move (source and destination are the same)
  if [[ "$source_file" == "$dest_file" ]]; then
    echo "Error: Source and destination are the same" >&2
    exit 1
  fi
  
  # Check write permissions on destination directory
  local dest_parent_dir="$BIN_DIR"
  [[ -n "$dest_dir" ]] && dest_parent_dir="$BIN_DIR/$dest_dir"
  if [[ -d "$dest_parent_dir" ]] && [[ ! -w "$dest_parent_dir" ]]; then
    echo "Error: No write permission for destination directory: $dest_parent_dir" >&2
    exit 1
  fi
  
  # Create destination directories if needed
  if [[ -n "$dest_dir" ]]; then
    if ! mkdir -p "$BIN_DIR/$dest_dir" 2>/dev/null; then
      echo "Error: Failed to create destination directory: $BIN_DIR/$dest_dir" >&2
      exit 1
    fi
  fi
  
  # Move script file
  if ! mv "$source_file" "$dest_file" 2>/dev/null; then
    echo "Error: Failed to move script file" >&2
    exit 1
  fi
  echo "âœ“ Moved script: $source -> $destination"

  # Update inline documentation in script if name changed
  if [[ "$source_name" != "$dest_name" ]]; then
    # Update script name references in DOC_TOKEN section
    local temp_script="$dest_file.tmp"
    sed "s/# $source_name -/# $dest_name -/g" "$dest_file" > "$temp_script"
    mv "$temp_script" "$dest_file"
    chmod +x "$dest_file"  # Ensure script remains executable
    echo "âœ“ Updated script inline documentation"
  fi
  
  # Clean up empty source directories (including parent directories)
  if [[ -n "$source_dir" ]]; then
    # Clean up bin directories
    local dir_to_check="$source_dir"
    while [[ -n "$dir_to_check" ]]; do
      if [[ -d "$BIN_DIR/$dir_to_check" && -z "$(ls -A "$BIN_DIR/$dir_to_check" 2>/dev/null)" ]]; then
        rmdir "$BIN_DIR/$dir_to_check" 2>/dev/null && echo "âœ“ Removed empty directory: bin/$dir_to_check"
      else
        break  # Directory not empty or doesn't exist, stop checking parents
      fi
      # Move to parent directory
      dir_to_check="$(dirname "$dir_to_check")"
      [[ "$dir_to_check" == "." ]] && break
    done
  fi
  
  echo "Successfully moved/renamed script: $source -> $destination"
  echo "Run with: dr $destination"
}

run_script() {
  local name="$1"
  shift
  local file
  file=$(find_script_file "$name")
  if [[ -z "$file" ]]; then
    echo "Error: Script '$name' not found" >&2
    echo "Use 'dr -l' to list available scripts" >&2
    exit 1
  fi
  "$file" "$@"
}

# Main command parser
case "${1:-}" in
-l | -L)
  show_docs=0
  [[ "$1" == "-L" ]] && show_docs=1
  scope="${2:-}" # optional second arg
  list_scripts "$show_docs" "$scope"
  ;;
add)
  [[ -z "${2:-}" ]] && {
    echo "Usage: dr add <name>"
    exit 1
  }
  add_script "$2"
  ;;
edit)
  [[ -z "${2:-}" ]] && {
    echo "Usage: dr edit <name>"
    exit 1
  }
  echo "Editing script: $2 ---- with editor: $EDITOR"
  edit_script "$2"
  ;;
move | rename | mv)
  [[ -z "${2:-}" || -z "${3:-}" ]] && {
    echo "Usage: dr $1 <source> <destination>"
    echo "Examples:"
    echo "  dr move oldName newName        # Simple rename"
    echo "  dr move gitCmd git/gitCmd      # Move to folder"
    echo "  dr move folderA/cmd folderB/cmd # Move between folders"
    echo "  dr move oldName folder/newName # Rename and move"
    exit 1
  }
  move_script "$2" "$3"
  ;;
help)
  [[ -z "${2:-}" ]] && {
    echo "Usage: dr help <name>"
    exit 1
  }
  show_help "$2"
  ;;
yadm-init)
  check_prerequisites
  if ! command -v yadm_init >/dev/null 2>&1; then
    echo "Error: Collections helper not available" >&2
    exit 1
  fi
  yadm_init
  ;;
collections)
  check_prerequisites
  if ! command -v interactive_collection_menu >/dev/null 2>&1; then
    echo "Error: Collections helper not available" >&2
    exit 1
  fi
  case "${2:-}" in
  "")
    # No arguments - run interactive menu
    interactive_collection_menu
    ;;
  add)
    [[ -z "${3:-}" ]] && {
      echo "Usage: dr collections add <github-url>"
      echo "Example: dr collections add https://github.com/user/repo"
      exit 1
    }
    add_collection_url "$3"
    ;;
  list)
    list_collection_urls
    ;;
  remove)
    [[ -z "${3:-}" ]] && {
      echo "Usage: dr collections remove <number>"
      echo "Run 'dr collections list' to see numbers"
      exit 1
    }
    remove_collection_url "$3"
    ;;
  *)
    echo "Usage: dr collections [command]"
    echo
    echo "Commands:"
    echo "  (no args)         Interactive collection browser and importer"
    echo "  add <url>         Add GitHub repository URL to collections"
    echo "  list              List configured collection URLs"
    echo "  remove <number>   Remove collection URL by number"
    echo
    echo "Examples:"
    echo "  dr collections                                        # Interactive mode"
    echo "  dr collections add https://github.com/user/repo.git   # Add collection"
    echo "  dr collections list                                   # List collections"
    echo "  dr collections remove 1                               # Remove collection #1"
    ;;
  esac
  ;;
aliases)
  check_prerequisites
  if [[ $(type -t aliases_init) != "function" ]]; then
    echo "Error: Aliases helper not available" >&2
    exit 1
  fi
  case "${2:-}" in
  init)
    aliases_init
    ;;
  add)
    [[ -z "${3:-}" || -z "${4:-}" ]] && {
      echo "Usage: dr aliases add <name> <command> [--category <category>]"
      echo "Examples:"
      echo "  dr aliases add ll 'ls -la'"
      echo "  dr aliases add gs 'git status' --category git"
      echo "  dr aliases add dc 'docker-compose' --category docker"
      exit 1
    }
    name="$3"
    command="$4"
    category=""
    # Check for --category flag
    if [[ "${5:-}" == "--category" && -n "${6:-}" ]]; then
      category="$6"
    fi
    aliases_add "$name" "$command" "$category"
    ;;
  list)
    show_categories="false"
    filter_category=""
    # Check for flags
    if [[ "${3:-}" == "--categories" ]]; then
      show_categories="true"
    elif [[ "${3:-}" == "--category" && -n "${4:-}" ]]; then
      filter_category="$4"
    fi
    aliases_list "$show_categories" "$filter_category"
    ;;
  edit)
    [[ -z "${3:-}" ]] && {
      echo "Usage: dr aliases edit <name>"
      exit 1
    }
    aliases_edit "$3"
    ;;
  remove | rm)
    [[ -z "${3:-}" ]] && {
      echo "Usage: dr aliases remove <name>"
      exit 1
    }
    aliases_remove "$3"
    ;;
  reload)
    aliases_reload
    ;;
  *)
    echo "Usage: dr aliases <command>"
    echo "Commands:"
    echo "  init                          Initialize aliases system"
    echo "  add <name> <command>          Add new alias"
    echo "  add <name> <cmd> --category <cat>  Add alias to specific category"
    echo "  list                          List all aliases"
    echo "  list --categories             List all aliases with category info"
    echo "  list --category <name>        List aliases in specific category"
    echo "  edit <name>                   Edit existing alias"
    echo "  remove <name>                 Remove alias (alias: rm)"
    echo "  reload                        Reload aliases in current shell"
    echo
    echo "Examples:"
    echo "  dr aliases init"
    echo "  dr aliases add ll 'ls -la'"
    echo "  dr aliases add gs 'git status' --category git"
    echo "  dr aliases list --category git"
    echo "  dr aliases edit ll"
    echo "  dr aliases remove gs"
    echo "  dr aliases reload"
    ;;
  esac
  ;;
config)
  check_prerequisites
  if [[ $(type -t config_init) != "function" ]]; then
    echo "Error: Config helper not available" >&2
    exit 1
  fi
  case "${2:-}" in
  init)
    config_init
    ;;
  set)
    [[ -z "${3:-}" || -z "${4:-}" ]] && {
      echo "Usage: dr config set <key> <value> [--category <category>] [--secure]"
      echo "Examples:"
      echo "  dr config set API_KEY abc123"
      echo "  dr config set DB_HOST localhost --category dev"
      echo "  dr config set SECRET_TOKEN xyz789 --secure"
      echo "  dr config set API_URL https://api.example.com --category api"
      exit 1
    }
    key="$3"
    value="$4"
    category=""
    secure="false"
    # Check for flags
    shift 4
    while [[ $# -gt 0 ]]; do
      case "$1" in
      --category)
        [[ -z "${2:-}" ]] && {
          echo "Error: --category requires a category name" >&2
          exit 1
        }
        category="$2"
        shift 2
        ;;
      --secure)
        secure="true"
        shift
        ;;
      *)
        echo "Error: Unknown option: $1" >&2
        exit 1
        ;;
      esac
    done
    config_set "$key" "$value" "$category" "$secure"
    ;;
  get)
    [[ -z "${3:-}" ]] && {
      echo "Usage: dr config get <key> [--show-value]"
      echo "Examples:"
      echo "  dr config get API_KEY"
      echo "  dr config get SECRET_TOKEN --show-value  # Show actual value for secure keys"
      exit 1
    }
    key="$3"
    show_masked="false"
    if [[ "${4:-}" == "--show-value" ]]; then
      show_masked="true"
    fi
    config_get "$key" "$show_masked"
    ;;
  list)
    show_categories="false"
    filter_category=""
    show_values="true"
    # Check for flags
    shift 2
    while [[ $# -gt 0 ]]; do
      case "$1" in
      --categories)
        show_categories="true"
        shift
        ;;
      --category)
        [[ -z "${2:-}" ]] && {
          echo "Error: --category requires a category name" >&2
          exit 1
        }
        filter_category="$2"
        shift 2
        ;;
      --keys-only)
        show_values="false"
        shift
        ;;
      *)
        echo "Error: Unknown option: $1" >&2
        exit 1
        ;;
      esac
    done
    config_list "$show_categories" "$filter_category" "$show_values"
    ;;
  edit)
    [[ -z "${3:-}" ]] && {
      echo "Usage: dr config edit <key>"
      echo "Example: dr config edit API_KEY"
      exit 1
    }
    config_edit "$3"
    ;;
  unset | remove | rm)
    [[ -z "${3:-}" ]] && {
      echo "Usage: dr config unset <key>"
      echo "Example: dr config unset API_KEY"
      exit 1
    }
    config_unset "$3"
    ;;
  reload)
    config_reload
    ;;
  *)
    echo "Usage: dr config <command>"
    echo "Commands:"
    echo "  init                          Initialize configuration system"
    echo "  set <key> <value>             Set configuration value"
    echo "  set <key> <val> --category <cat>  Set config in specific category"
    echo "  set <key> <val> --secure      Mark as secure/sensitive"
    echo "  get <key>                     Get configuration value (masked if secure)"
    echo "  get <key> --show-value        Get actual value (even if secure)"
    echo "  list                          List all configuration"
    echo "  list --categories             List all config with category info"
    echo "  list --category <name>        List config in specific category"
    echo "  list --keys-only              List only keys (no values)"
    echo "  edit <key>                    Edit existing configuration"
    echo "  unset <key>                   Remove configuration (aliases: remove, rm)"
    echo "  reload                        Reload config in current shell"
    echo
    echo "Examples:"
    echo "  dr config init"
    echo "  dr config set API_KEY abc123"
    echo "  dr config set DB_HOST localhost --category dev"
    echo "  dr config set SECRET_TOKEN xyz789 --secure"
    echo "  dr config get API_KEY"
    echo "  dr config list --category api"
    echo "  dr config edit API_KEY"
    echo "  dr config unset API_KEY"
    echo "  dr config reload"
    ;;
  esac
  ;;
-v | --version | version)
  echo "dr version $DRUN_VERSION"
  exit 0
  ;;
"" | -h | --help)
  echo "dr <command> [args...]"
  echo
  echo "Commands"
  echo "  -l                  List all scripts (names only)"
  echo "  -L                  List scripts with docs, optionally scoped"
  echo "  -l/L [folder/]      List scripts within the scoped folder"
  echo "  add <name>          Create and open <name>.sh in editor"
  echo "  edit <name>         Open existing script in editor"
  echo "  move <src> <dst>    Move/rename script (aliases: rename, mv)"
  echo "  help <name>         Show inline docs for <name>"
  echo "  <name> [argsâ€¦]      Execute script <name> from anywhere"
  echo
  echo "Aliases Management"
  echo "  aliases init        Initialize aliases system with shell integration"
  echo "  aliases add <name> <command>  Add new alias"
  echo "  aliases list        List all aliases"
  echo "  aliases edit <name> Edit existing alias"
  echo "  aliases remove <name> Remove alias"
  echo "  aliases reload      Reload aliases in current shell"
  echo
  echo "Configuration Management"
  echo "  config init         Initialize configuration system with shell integration"
  echo "  config set <key> <value>  Set global configuration variable"
  echo "  config get <key>    Get configuration value (masked if secure)"
  echo "  config list         List all configuration variables"
  echo "  config edit <key>   Edit existing configuration"
  echo "  config unset <key>  Remove configuration variable"
  echo "  config reload       Reload config variables in current shell"
  echo
  echo "Integration & Collections"
  echo "  yadm-init           Setup DotRun to work with existing yadm repository"
  echo "  collections         Interactive collection browser and importer"
  echo "  collections add <url> Add GitHub repository URL to collections"
  echo "  collections list    List configured collection URLs"
  echo "  collections remove <number> Remove collection URL by number"
  echo
  echo "Environment Variables"
  echo "  DR_CONFIG         Override root (default \$HOME/.config/dotrun)"
  echo "  EDITOR              Command to open editor (default: auto-detect)"
  echo
  echo "Examples"
  echo "  dr add myScript              # Create new script"
  echo "  dr move oldName newName      # Rename script"
  echo "  dr mv script tools/script    # Move to folder"
  echo "  dr yadm-init                 # Setup with existing yadm dotfiles"
  echo "  dr collections               # Interactive collection browser"
  echo "  dr collections add https://github.com/team/scripts.git"
  echo "  dr collections list          # List configured collections"
  echo "  dr collections remove 1      # Remove first collection"
  echo "  dr aliases init                      # Setup aliases system"
  echo "  dr aliases add ll 'ls -la'           # Add simple alias"
  echo "  dr aliases add gs 'git status' --category git  # Add categorized alias"
  echo "  dr config init                       # Setup config system"
  echo "  dr config set API_KEY abc123         # Set API key"
  echo "  dr config set DB_HOST localhost --category dev  # Set categorized config"
  echo "  dr config set SECRET_TOKEN xyz789 --secure      # Set secure config"
  echo
  echo "Note: dr auto-runs ShellCheck after add/edit if available"
  echo "      'glow' is recommended for beautiful markdown rendering"
  exit 0
  ;;
*)
  if [[ -n "${1:-}" ]]; then
    run_script "$@"
  else
    echo "Error: No command provided" >&2
    echo "Run 'dr --help' for usage information" >&2
    exit 1
  fi
  ;;
esac
