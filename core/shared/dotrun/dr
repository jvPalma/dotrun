#!/usr/bin/env bash

# shellcheck disable=SC2155
# shellcheck disable=SC1091
# shellcheck disable=SC2016
# Strict error handling
set -euo pipefail

IFS=$'\n\t'

DOC_TOKEN="### DOC"

# Version - Read from VERSION file or fallback to 3.1.0
# Resolve symlinks to find the actual script location
SCRIPT_PATH="${BASH_SOURCE[0]}"
while [[ -L "$SCRIPT_PATH" ]]; do
  SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
  SCRIPT_PATH="$(readlink "$SCRIPT_PATH")"
  [[ "$SCRIPT_PATH" != /* ]] && SCRIPT_PATH="$SCRIPT_DIR/$SCRIPT_PATH"
done
SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"

if [[ -f "$SCRIPT_DIR/VERSION" ]]; then
  DRUN_VERSION="$(cat "$SCRIPT_DIR/VERSION")"
else
  DRUN_VERSION="3.1.0"  # Fallback if VERSION file not found
fi


_default_editor="$(command -v code >/dev/null && echo "code" || echo "nano")"
EDITOR="${EDITOR:-$_default_editor}"

# Validate EDITOR environment variable
if [[ -n "$EDITOR" ]] && ! command -v "$EDITOR" >/dev/null 2>&1; then
  echo "Warning: EDITOR '$EDITOR' not found in PATH, falling back to $_default_editor" >&2
  EDITOR="$_default_editor"
fi

# SHARED Configurations (must be defined before sourcing constants.sh)
SHARED_DR_PATH="${HOME}/.local/share/dotrun"
SHARED_DR_CORE_PATH="${SHARED_DR_PATH}/core"
SHARED_DR_HELPERS_PATH="${SHARED_DR_PATH}/helpers"

# Source constants.sh for paths, icons, and colors (single source of truth)
SHARED_DR_HELPERS_CONSTANTS="${SHARED_DR_HELPERS_PATH}/constants.sh"
if [[ -f "$SHARED_DR_HELPERS_CONSTANTS" ]]; then
  # shellcheck disable=SC1090
  source "$SHARED_DR_HELPERS_CONSTANTS"
fi

# Ensure user collection directories exist
mkdir -p "$USER_COLLECTION_SCRIPTS"
mkdir -p "$USER_COLLECTION_HELPERS"

# Core system paths (depend on SCRIPT_DIR, must stay here)
SHARED_DR_CORE_SCRIPTS="$SCRIPT_DIR/core/scripts.sh"
SHARED_DR_CORE_ALIASES="$SCRIPT_DIR/core/aliases.sh"
SHARED_DR_CORE_CONFIGS="$SCRIPT_DIR/core/config.sh"
SHARED_DR_CORE_COLLECTIONS="$SCRIPT_DIR/core/collections.sh"

# Helper paths
SHARED_DR_HELPERS_LINT="${SHARED_DR_HELPERS_PATH}/lint.sh"
SHARED_DR_HELPERS_LIST_TREE="${SHARED_DR_HELPERS_PATH}/list_feature_files_tree.sh"

# Templates
SHARED_DR_TEMPLATES_PATH="${SHARED_DR_CORE_PATH}/templates"
TEMPLATE_NEW_SCRIPT="${SHARED_DR_TEMPLATES_PATH}/script.sh"

# Source lint helper (small, frequently used)
# shellcheck disable=SC1090
[[ -f "$SHARED_DR_HELPERS_LINT" ]] && source "$SHARED_DR_HELPERS_LINT"

# Lazy-load module functions (source only when needed)
_load_scripts_module() {
  if [[ $(type -t set_script) != "function" ]]; then
    # shellcheck disable=SC1090
    [[ -f "$SHARED_DR_CORE_SCRIPTS" ]] && source "$SHARED_DR_CORE_SCRIPTS"
  fi
}

_load_aliases_module() {
  if [[ $(type -t aliases_set) != "function" ]]; then
    # shellcheck disable=SC1090
    [[ -f "$SHARED_DR_CORE_ALIASES" ]] && source "$SHARED_DR_CORE_ALIASES"
  fi
}

_load_configs_module() {
  if [[ $(type -t config_set) != "function" ]]; then
    # shellcheck disable=SC1090
    [[ -f "$SHARED_DR_CORE_CONFIGS" ]] && source "$SHARED_DR_CORE_CONFIGS"
  fi
}

_load_collections_module() {
  if [[ $(type -t cmd_col_list) != "function" ]]; then
    # shellcheck disable=SC1090
    [[ -f "$SHARED_DR_CORE_COLLECTIONS" ]] && source "$SHARED_DR_CORE_COLLECTIONS"
  fi
}

# Main command parser
case "${1:-}" in
-r|reload)
  # Feature-agnostic reload command
  drrc="$HOME/.drrc"

  if [[ ! -f "$drrc" ]]; then
    echo -e "${COLOR_SCRIPTS}Error:${COLOR_RESET} ~/.drrc not found" >&2
    echo "DotRun may not be properly installed or initialized." >&2
    exit 1
  fi

  # Display reload instructions with colors
  echo -e "${COLOR_SCRIPTS}ðŸ”„ Reloading DotRun...${COLOR_RESET}"
  echo ""
  echo -e "${COLOR_DOC}Note: Scripts run in subshells and cannot modify the parent shell environment.${COLOR_RESET}"
  echo ""
  echo -e "To reload DotRun in your ${COLOR_BOLD}current shell${COLOR_RESET}, run:"
  echo -e "  ${COLOR_SCRIPTS}source ~/.drrc${COLOR_RESET}"
  echo ""
  echo -e "Or create a convenient alias:"
  echo -e "  ${COLOR_SCRIPTS}alias drr='source ~/.drrc'${COLOR_RESET}"
  echo ""
  echo -e "Then you can simply type: ${COLOR_SCRIPTS}drr${COLOR_RESET}"
  ;;
-l | -L)
  _load_scripts_module
  show_docs=0
  [[ "$1" == "-L" ]] && show_docs=1
  scope="${2:-}" # optional second arg
  list_scripts "$show_docs" "$scope"
  ;;
-s|scripts)
  # Script management namespace
  _load_scripts_module
  case "${2:-}" in
  set)
    [[ -z "${3:-}" ]] && {
      echo "Usage: dr $1 set <name>"
      exit 1
    }
    set_script "$3"
    ;;
  move|rename)
    [[ -z "${3:-}" || -z "${4:-}" ]] && {
      echo "Usage: dr $1 move <source> <destination>"
      echo "Examples:"
      echo "  dr $1 move oldName newName          ${DIM}# Simple rename${NC}"
      echo "  dr $1 move gitCmd git/gitCmd        ${DIM}# Move to folder${NC}"
      echo "  dr $1 move folderA/cmd folderB/cmd  ${DIM}# Move between folders${NC}"
      echo "  dr $1 move oldName folder/newName   ${DIM}# Rename and move${NC}"
      exit 1
    }
    move_script "$3" "$4"
    ;;
  help)
    [[ -z "${3:-}" ]] && {
      echo "Usage: dr $1 help <name>"
      exit 1
    }
    show_script_help "$3"
    ;;
  rm)
    [[ -z "${3:-}" ]] && {
      echo "Usage: dr $1 rm <name>"
      exit 1
    }
    remove_script "$3"
    ;;
  list)
    # Optional folder scope for list
    show_docs=0
    scope="${3:-}"
    list_scripts "$show_docs" "$scope"
    ;;
  *)
    echo "Usage: dr $1 <command> [args]"
    echo "       dr $1 <scriptname>  (runs the script)"
    echo
    echo "Default: Runs the script (no command needed)"
    echo
    echo "Commands:"
    echo "  <scriptname>        Run script (default action)"
    echo "  set <name>          Create or open a script in editor"
    echo "  move <src> <dst>    Move/rename a script"
    echo "  rm <name>           Remove a script"
    echo "  help <name>         Show script documentation"
    echo
    echo "Use 'dr -l' or 'dr -L' to list scripts."
    echo
    echo "Examples:"
    echo "  dr $1 myScript          # Runs myScript"
    echo "  dr $1 set myScript      # Opens myScript in editor"
    echo "  dr $1 move old new      # Renames script"
    echo "  dr $1 rm myScript       # Removes script"
    echo "  dr $1 help myScript     # Shows documentation"
    ;;
  esac
  ;;
set)
  _load_scripts_module
  [[ -z "${2:-}" ]] && {
    echo "Usage: dr set <name>"
    exit 1
  }
  set_script "$2"
  ;;
move | rename | mv)
  _load_scripts_module
  [[ -z "${2:-}" || -z "${3:-}" ]] && {
    echo "Usage: dr $1 <source> <destination>"
    echo "Examples:"
    echo "  dr move oldName newName        # Simple rename"
    echo "  dr move gitCmd git/gitCmd      # Move to folder"
    echo "  dr move folderA/cmd folderB/cmd # Move between folders"
    echo "  dr move oldName folder/newName # Rename and move"
    exit 1
  }
  move_script "$2" "$3"
  ;;
help)
  _load_scripts_module
  [[ -z "${2:-}" ]] && {
    echo "Usage: dr help <name>"
    exit 1
  }
  show_script_help "$2"
  ;;
docs)
  _load_scripts_module
  [[ -z "${2:-}" ]] && {
    echo "Usage: dr docs <name>"
    exit 1
  }
  show_script_help "$2"
  ;;
rm)
  _load_scripts_module
  [[ -z "${2:-}" ]] && {
    echo "Usage: dr rm <name>"
    exit 1
  }
  remove_script "$2"
  ;;
-col|collections)
  _load_collections_module
  if [[ $(type -t cmd_col_init) != "function" ]]; then
    echo "Error: Collections helper not available" >&2
    exit 1
  fi
  case "${2:-}" in
  "")
    # No arguments - run interactive browser
    cmd_col_interactive
    ;;
  init)
    cmd_col_init
    ;;
  add)
    [[ -z "${3:-}" ]] && {
      echo "Usage: dr $1 add <github-url>"
      echo "Example: dr $1 add https://github.com/user/repo"
      exit 1
    }
    cmd_col_add "$3"
    ;;
  list)
    cmd_col_list
    ;;
  sync)
    cmd_col_sync
    ;;
  update)
    # Allow both interactive (no args) and direct (with name) modes
    cmd_col_update "${3:-}"
    ;;
  remove)
    [[ -z "${3:-}" ]] && {
      echo "Usage: dr $1 remove <collection-name>"
      echo "Run 'dr $1 list' to see installed collections"
      exit 1
    }
    cmd_col_remove "$3"
    ;;
  --help|-h|help)
    # Color codes for help output
    BOLD=$'\e[1m'
    CYAN=$'\e[36m'
    GREEN=$'\e[32m'
    BLUE=$'\e[34m'
    YELLOW=$'\e[33m'
    GRAY=$'\e[90m'
    RESET=$'\e[0m'

    cat <<EOF
${BOLD}${CYAN}DotRun Collections System${RESET}

A version-controlled, copy-based system for sharing and managing script collections from
Git repositories. Collections use SHA256 hash tracking for modification detection and
provide interactive conflict resolution during updates.

${BOLD}ARCHITECTURE${RESET}

  ${GRAY}Copy-Based Imports${RESET}   Resources are ${BOLD}copied${RESET} to your config (not symlinked)
                     You can freely edit imported files without breaking updates

  ${GRAY}Hash Tracking${RESET}        SHA256 hashes (8-char) detect if you've modified imported files
                     Update workflow changes based on modification status

  ${GRAY}Git Versioning${RESET}       Collections use semantic version tags (v1.0.0, v1.1.0, etc.)
                     \`sync\` checks for updates, \`update\` applies them interactively

  ${GRAY}Persistent Clones${RESET}    Collections stored in \$DR_CONFIG/collections/ as full git repos
                     Enables diff, merge, and version comparison

${BOLD}COMMANDS${RESET}

  ${GREEN}dr -col${RESET}                  ${GRAY}[Interactive Browser]${RESET}
                           Browse installed collections and import additional resources
                           Shows update badges (ðŸ”„) for collections with available updates

  ${GREEN}dr -col init${RESET}             ${GRAY}[For Collection Authors]${RESET}
                           Initialize collection structure in current directory
                           Creates: dotrun.collection.yml, scripts/, aliases/, helpers/, configs/
                           Use when creating a new collection to share

  ${GREEN}dr -col add${RESET} ${YELLOW}<url>${RESET}         ${GRAY}[Install Collection]${RESET}
                           Clone collection from GitHub, display resource menu, import selected
                           Tracks: version, URL, imported files with hashes
                           Example: dr -col add https://github.com/user/devtools.git

  ${GREEN}dr -col list${RESET}             ${GRAY}[Show Installed]${RESET}
                           List all installed collections with:
                           - Collection name and current version
                           - Repository URL
                           - Count of imported resources by type

  ${GREEN}dr -col sync${RESET}             ${GRAY}[Check Updates]${RESET}
                           Fetch latest tags from all collections, compare versions
                           Shows which files changed in each update
                           Non-destructive: only checks, doesn't modify files

  ${GREEN}dr -col update${RESET} ${YELLOW}[name]${RESET}     ${GRAY}[Apply Updates]${RESET}
                           Update collection to latest version with conflict resolution
                           ${YELLOW}[name]${RESET} optional - shows interactive selection if omitted

                           For ${BOLD}unmodified${RESET} files: [U]pdate, [D]iff, [S]kip
                           For ${BOLD}modified${RESET} files:   [K]eep, [O]verwrite, [D]iff, [M]erge, [B]ackup
                           For ${BOLD}new${RESET} files:        [I]mport, [V]iew, [S]kip

  ${GREEN}dr -col remove${RESET} ${YELLOW}<name>${RESET}     ${GRAY}[Remove Tracking]${RESET}
                           Remove collection from tracking and delete repository clone
                           ${YELLOW}NOTE${RESET}: Imported files remain in your config (you own them)
                           Delete manually if unwanted

${BOLD}WORKFLOWS${RESET}

  ${CYAN}â†’ As a Collection User${RESET}

    1. Discover and install:
       ${GRAY}dr -col add https://github.com/team/deployment-scripts.git${RESET}

    2. Select resources to import from interactive menu
       Scripts, aliases, helpers, configs displayed by category

    3. Check for updates periodically:
       ${GRAY}dr -col sync${RESET}

    4. Apply updates when available:
       ${GRAY}dr -col update deployment-scripts${RESET}

    5. Resolve conflicts interactively:
       - Keep your changes or accept collection's version
       - View diffs to understand changes
       - Merge conflicting edits when possible

  ${CYAN}â†’ As a Collection Author${RESET}

    1. Initialize collection structure:
       ${GRAY}cd ~/my-team-scripts && dr -col init${RESET}

    2. Edit dotrun.collection.yml metadata:
       ${GRAY}name, version, description, author, repository${RESET}

    3. Organize resources in subdirectories:
       ${GRAY}scripts/    - Executable scripts (.sh)${RESET}
       ${GRAY}aliases/    - Shell aliases (.aliases)${RESET}
       ${GRAY}helpers/    - Sourced helper modules${RESET}
       ${GRAY}configs/    - Configuration files (.config)${RESET}

    4. Commit and tag with semantic versions:
       ${GRAY}git add . && git commit -m "Add deployment automation"${RESET}
       ${GRAY}git tag v1.0.0 && git push --tags${RESET}

    5. Share repository URL with your team
       They install with: ${GRAY}dr -col add <your-repo-url>${RESET}

    6. For updates, increment version and create new tag:
       ${GRAY}# Edit dotrun.collection.yml: version: "1.1.0"${RESET}
       ${GRAY}git commit -am "Add monitoring script" && git tag v1.1.0${RESET}
       ${GRAY}git push --tags${RESET}

${BOLD}COLLECTION STRUCTURE${RESET}

  ${GRAY}Repository Layout:${RESET}

    dotrun.collection.yml    ${GRAY}# Required metadata${RESET}
    scripts/                 ${GRAY}# Executable scripts${RESET}
      deploy.sh
      backup.sh
      git/                   ${GRAY}# Subdirectories preserved on import${RESET}
        sync.sh
    aliases/                 ${GRAY}# Shell aliases${RESET}
      01-git.aliases
      02-docker.aliases
    helpers/                 ${GRAY}# Sourced modules${RESET}
      validation.sh
    configs/                 ${GRAY}# Global variables${RESET}
      01-api.config

  ${GRAY}Metadata (dotrun.collection.yml):${RESET}

    name: "deployment-tools"          ${GRAY}# Required: unique identifier${RESET}
    version: "1.0.0"                  ${GRAY}# Required: semantic version${RESET}
    description: "Deploy automation"  ${GRAY}# Required: brief description${RESET}
    author: "DevOps Team"             ${GRAY}# Required: creator name${RESET}
    repository: "https://github.com/team/deploy.git"  ${GRAY}# Required: git URL${RESET}
    license: "MIT"                    ${GRAY}# Optional${RESET}
    homepage: "https://docs.team.com" ${GRAY}# Optional${RESET}
    dependencies: []                  ${GRAY}# Optional: other collections${RESET}

${BOLD}TRACKING & STORAGE${RESET}

  ${GRAY}Collections Directory${RESET}   \$DR_CONFIG/collections/${YELLOW}<name>${RESET}/
                           Full git clone for each collection
                           Example: ~/.config/dotrun/collections/devtools/

  ${GRAY}Tracking Database${RESET}       ~/.local/share/dotrun/collections.conf
                           INI format with sections per collection
                           Stores: URL, version, path, imported files with hashes

  ${GRAY}Imported Resources${RESET}      \$DR_CONFIG/{scripts,aliases,helpers,configs}/
                           Copied from collection to your config
                           You own these files and can edit freely

${BOLD}CONFLICT RESOLUTION${RESET}

  When updating a collection, DotRun compares file hashes to detect modifications:

  ${GREEN}Unmodified File${RESET} (hash matches original)
    ${GRAY}[U]pdate${RESET}  - Overwrite with collection's new version
    ${GRAY}[D]iff${RESET}    - Show changes between versions
    ${GRAY}[S]kip${RESET}    - Keep current version, don't update

  ${YELLOW}Modified File${RESET} (you changed it after import)
    ${GRAY}[K]eep${RESET}     - Keep your version, skip update
    ${GRAY}[O]verwrite${RESET} - Replace with collection version (lose your changes)
    ${GRAY}[D]iff${RESET}     - Show 3-way diff: original | yours | collection's
    ${GRAY}[M]erge${RESET}    - Attempt 3-way merge (git merge-file)
    ${GRAY}[B]ackup${RESET}   - Save yours as .bak, then overwrite

  ${BLUE}New File${RESET} (added in collection update)
    ${GRAY}[I]mport${RESET}  - Copy to your config
    ${GRAY}[V]iew${RESET}    - Display file contents
    ${GRAY}[S]kip${RESET}    - Don't import

${BOLD}EXAMPLES${RESET}

  ${GRAY}# Install and browse collection${RESET}
  dr -col add https://github.com/user/devtools.git
  dr -col                                    ${GRAY}# Browse interactively${RESET}

  ${GRAY}# Check and apply updates${RESET}
  dr -col sync                               ${GRAY}# Check all for updates${RESET}
  dr -col update                             ${GRAY}# Interactive: select collection${RESET}
  dr -col update devtools                    ${GRAY}# Direct: update specific collection${RESET}

  ${GRAY}# Create and share a collection${RESET}
  mkdir ~/team-scripts && cd ~/team-scripts
  dr -col init                               ${GRAY}# Initialize structure${RESET}
  # ... add scripts to scripts/, aliases to aliases/ ...
  vim dotrun.collection.yml                  ${GRAY}# Edit metadata${RESET}
  git init && git add .
  git commit -m "Initial collection"
  git tag v1.0.0
  git remote add origin https://github.com/team/scripts.git
  git push -u origin master --tags

  ${GRAY}# Manage installed collections${RESET}
  dr -col list                               ${GRAY}# Show all installed${RESET}
  dr -col remove old-collection              ${GRAY}# Remove tracking${RESET}

${BOLD}TIPS & BEST PRACTICES${RESET}

  ${GRAY}For Users:${RESET}
  - Run ${GREEN}dr -col sync${RESET} regularly to stay updated
  - Use ${GRAY}[D]iff${RESET} option during updates to understand changes
  - Modified files won't be overwritten without confirmation
  - Imported files are yours - edit freely without breaking updates

  ${GRAY}For Authors:${RESET}
  - Use semantic versioning: MAJOR.MINOR.PATCH (1.0.0, 1.1.0, 2.0.0)
  - Increment MAJOR for breaking changes, MINOR for features, PATCH for fixes
  - Tag every release: ${GRAY}git tag v1.0.0${RESET}
  - Keep dotrun.collection.yml version in sync with git tags
  - Document breaking changes in scripts with ${GRAY}### DOC${RESET} blocks
  - Test imports in a clean environment before sharing

  ${GRAY}Version Management:${RESET}
  - Collections track installed version vs. available version
  - ${GREEN}sync${RESET} fetches tags but doesn't modify files
  - ${GREEN}update${RESET} checks out new tag and prompts for each changed file
  - Git history preserved - can always ${GRAY}git checkout${RESET} older versions

${GRAY}Use 'dr -col <command>' to manage collections. Both flag (-col) and subcommand${RESET}
${GRAY}(collections) styles work identically.${RESET}
EOF
    exit 0
    ;;
  *)
    echo "Usage: dr $1 [command]"
    echo
    echo "Commands:"
    echo "  (no args)         Interactive collection browser"
    echo "  init              Initialize collection structure for authors"
    echo "  add <url>         Install collection from GitHub repository"
    echo "  list              List installed collections with versions"
    echo "  sync              Check all collections for updates"
    echo "  update [name]     Update collection (interactive if no name given)"
    echo "  remove <name>     Remove collection tracking"
    echo "  --help, -h        Show detailed collections help"
    echo
    echo "Examples:"
    echo "  dr $1 init                                          # Initialize collection"
    echo "  dr $1 add https://github.com/user/repo              # Install collection"
    echo "  dr $1 list                                          # List collections"
    echo "  dr $1 sync                                          # Check for updates"
    echo "  dr $1 update                                        # Select interactively"
    echo "  dr $1 update my-scripts                             # Update specific one"
    echo "  dr $1 remove my-scripts                             # Remove collection"
    echo "  dr $1 --help                                        # Detailed guide"
    ;;
  esac
  ;;
-a|aliases)
  _load_aliases_module
  if [[ $(type -t aliases_init) != "function" ]]; then
    echo "Error: Aliases helper not available" >&2
    exit 1
  fi

  # Handle -l and -L flags first (before case statement)
  if [[ "${2:-}" == "-l" ]]; then
    list_aliases 0 "${3:-}"
    exit 0
  elif [[ "${2:-}" == "-L" ]]; then
    list_aliases 1 "${3:-}"
    exit 0
  fi

  case "${2:-}" in
  init)
    aliases_init
    ;;
  set)
    [[ -z "${3:-}" ]] && {
      echo "Usage: dr aliases set <path/to/file>" >&2
      echo "" >&2
      echo "Creates or opens an alias file for editing (idempotent)." >&2
      echo "One file can contain multiple aliases." >&2
      echo "" >&2
      echo "Examples:" >&2
      echo "  dr aliases set 01-git          # Opens ~/.config/dotrun/aliases/01-git.aliases" >&2
      echo "  dr aliases set cd/shortcuts    # Opens ~/.config/dotrun/aliases/cd/shortcuts.aliases" >&2
      exit 1
    }
    aliases_set "$3"
    ;;
  remove | rm)
    [[ -z "${3:-}" ]] && {
      echo "Usage: dr aliases rm <name>"
      exit 1
    }
    aliases_remove "$3"
    ;;
  help)
    [[ -z "${3:-}" ]] && {
      echo "Usage: dr aliases help <name>" >&2
      exit 1
    }
    aliases_help "$3"
    ;;
  move)
    [[ -z "${3:-}" ]] && {
      echo "Usage: dr aliases move <source> <destination>" >&2
      exit 1
    }
    aliases_move "$3" "${4:-}"
    ;;
  *)
    # Default action: if argument doesn't start with - and is not empty, treat as filename
    if [[ -n "${2:-}" && "${2:0:1}" != "-" ]]; then
      aliases_set "$2"
    else
      echo "Usage: dr -a [command] [args]"
      echo ""
      echo "Default: Opens alias file for editing (no command needed)"
      echo ""
      echo "Commands:"
      echo "  <name>                        Edit alias file (default action)"
      echo "  -l [folder/]                  List aliases (tree view, short)"
      echo "  -L [folder/]                  List aliases (tree view, with descriptions)"
      echo "  move <source> <dest>          Move/rename alias file"
      echo "  rm <name>                     Remove alias file"
      echo "  help <name>                   Show alias file documentation"
      echo "  init                          Initialize aliases folder structure"
      echo ""
      echo "Note: 'set' is optional - 'dr -a myalias' and 'dr -a set myalias' are equivalent"
      echo ""
      echo "Examples:"
      echo "  dr -a git-shortcuts           # Edit (or create) git-shortcuts.aliases"
      echo "  dr -a -l                      # List all aliases in tree format"
      echo "  dr -a -L cd/                  # List aliases in cd/ with descriptions"
      echo "  dr -a move old-name new-name  # Rename alias file"
      echo "  dr -a rm unused-alias         # Remove alias file"
      echo "  dr -a help git-shortcuts      # Show documentation for alias file"
      echo "  dr -a init                    # Initialize aliases directory"
    fi
    ;;
  esac
  ;;
-c|config)
  _load_configs_module
  if [[ $(type -t config_set) != "function" ]]; then
    echo "Error: Config helper not available" >&2
    exit 1
  fi
  # Handle -l and -L flags first (before case statement)
  if [[ "${2:-}" == "-l" ]]; then
    list_configs 0 "${3:-}"
    exit 0
  elif [[ "${2:-}" == "-L" ]]; then
    list_configs 1 "${3:-}"
    exit 0
  fi
  case "${2:-}" in
  set)
    [[ -z "${3:-}" ]] && {
      echo "Usage: dr config set <path/to/file>" >&2
      echo "" >&2
      echo "Creates or opens a config file for editing (idempotent)." >&2
      echo "One file can contain multiple configuration exports." >&2
      echo "" >&2
      echo "Examples:" >&2
      echo "  dr config set 01-main          # Opens ~/.config/dotrun/configs/01-main.config" >&2
      echo "  dr config set api/keys         # Opens ~/.config/dotrun/configs/api/keys.config" >&2
      exit 1
    }
    config_set "$3"
    ;;
  list)
    show_categories="false"
    filter_category=""
    # Check for flags
    if [[ "${3:-}" == "--categories" ]]; then
      show_categories="true"
    elif [[ "${3:-}" == "--category" && -n "${4:-}" ]]; then
      filter_category="$4"
    fi
    config_list "$show_categories" "$filter_category"
    ;;
  move)
    [[ -z "${3:-}" ]] && {
      echo "Usage: dr config move <source> <destination>" >&2
      exit 1
    }
    config_move "$3" "${4:-}"
    ;;
  help)
    [[ -z "${3:-}" ]] && {
      echo "Usage: dr config help <name>" >&2
      exit 1
    }
    config_help "$3"
    ;;
  remove | rm)
    [[ -z "${3:-}" ]] && {
      echo "Usage: dr config rm <name>"
      exit 1
    }
    config_remove "$3"
    ;;
  init)
    # Initialize config folder structure
    config_dir="${DR_CONFIG:-$HOME/.config/dotrun}/configs"
    if [[ ! -d "$config_dir" ]]; then
      mkdir -p "$config_dir"
      echo "âœ“ Created configs directory: $config_dir"
    else
      echo "Configs directory already exists: $config_dir"
    fi
    ;;
  "")
    # Show help when no arguments
    echo "Usage: dr -c <configname>  (opens config for editing)"
    echo "       dr -c <command> [args...]"
    echo
    echo "Commands:"
    echo "  <configname>                  Add/edit config file (default action)"
    echo "  -l [FOLDER/]                  List configs (tree view)"
    echo "  -L [FOLDER/]                  List configs with descriptions"
    echo "  move <source> <dest>          Move/rename config file"
    echo "  rm <path/to/file>             Remove config file"
    echo "  help <path/to/file>           Show config documentation"
    echo "  init                          Initialize configs folder"
    echo
    echo "Note: 'set' is optional - 'dr -c myconfig' and 'dr -c set myconfig' are equivalent"
    echo
    echo "Examples:"
    echo "  dr -c myconfig                # Opens myconfig.config for editing"
    echo "  dr -c -l                      # List all configs"
    echo "  dr -c api/keys                # Opens api/keys.config for editing"
    echo "  dr -c move old new            # Rename config file"
    echo "  dr -c rm api/keys             # Remove config file"
    ;;
  -*)
    # Unknown flag
    echo "Error: Unknown flag ${2}" >&2
    exit 1
    ;;
  *)
    # Default action: if argument doesn't start with - and is not empty, treat as filename
    if [[ -n "${2:-}" && "${2:0:1}" != "-" ]]; then
      config_set "$2"
    else
      echo "Usage: dr -c <configname>  (opens config for editing)"
      echo "       dr -c <command> [args...]"
      echo
      echo "Run 'dr -c' for full command list"
    fi
    ;;
  esac
  ;;
-v | --version | version)
  echo "dr version $DRUN_VERSION"
  exit 0
  ;;
"" | -h | --help)
  # Color codes for help output
  BOLD=$'\e[1m'
  CYAN=$'\e[36m'
  GREEN=$'\e[32m'
  PURPLE=$'\e[35m'
  RED=$'\e[31m'
  YELLOW=$'\e[33m'
  BLUE=$'\e[34m'
  GRAY=$'\e[90m'
  RESET=$'\e[0m'

  cat <<EOF

${BOLD}${CYAN}dr${RESET} ${GRAY}<command> [args...]${RESET}

${BOLD}Core Commands${RESET}
  ${CYAN}-l${RESET}                  List all scripts (names only)
  ${CYAN}-L${RESET}                  List scripts with docs, optionally scoped
  ${CYAN}-l/L${RESET} ${YELLOW}[folder/]${RESET}      List scripts within the scoped folder
  ${CYAN}-r/reload${RESET}           Reload full DotRun tool features

${BOLD}${GREEN}Script Management${RESET} ${GRAY}(${GREEN}-s${RESET}${GRAY} or ${GREEN}scripts${RESET}${GRAY}, or ${GREEN}nothing${RESET}${GRAY} - the \`Script\` feature is default behavior)${RESET}
  ${GREEN}set${RESET} ${YELLOW}<name>${RESET}       Create or open ${YELLOW}<name>${RESET}.sh in editor (idempotent)
  ${GREEN}move${RESET} ${YELLOW}<src> <dst>${RESET} Move/rename script
  ${GREEN}rm${RESET} ${YELLOW}<name>${RESET}        Remove script
  ${GREEN}help${RESET} ${YELLOW}<name>${RESET}      Show inline docs
  ${GREEN}${YELLOW}<name>${RESET} ${GRAY}[argsâ€¦]${RESET}   Execute script ${YELLOW}<name>${RESET} from anywhere

${BOLD}${PURPLE}Aliases Management${RESET} ${GRAY}(${PURPLE}-a${RESET}${GRAY} or ${PURPLE}aliases${RESET}${GRAY})${RESET}
  ${PURPLE}-a${RESET} ${YELLOW}<path/to/file>${RESET}        Create or edit alias file (default action)
  ${PURPLE}-a -l${RESET} ${YELLOW}[folder/]${RESET}         List aliases in tree view (short)
  ${PURPLE}-a -L${RESET} ${YELLOW}[folder/]${RESET}         List aliases in tree view (with descriptions)
  ${PURPLE}-a move${RESET} ${YELLOW}<src> <dst>${RESET}     Move/rename alias file
  ${PURPLE}-a rm${RESET} ${YELLOW}<file>${RESET}            Remove alias file
  ${PURPLE}-a help${RESET} ${YELLOW}<file>${RESET}          Show alias documentation
  ${PURPLE}-a init${RESET}               Initialize aliases folder

${BOLD}${RED}Configuration Management${RESET} ${GRAY}(${RED}-c${RESET}${GRAY} or ${RED}config${RESET}${GRAY})${RESET}
  ${RED}-c${RESET} ${YELLOW}<path/to/file>${RESET}        Create or edit config file (default action)
  ${RED}-c -l${RESET} ${YELLOW}[folder/]${RESET}         List configs in tree view (short)
  ${RED}-c -L${RESET} ${YELLOW}[folder/]${RESET}         List configs in tree view (with descriptions)
  ${RED}-c move${RESET} ${YELLOW}<src> <dst>${RESET}     Move/rename config file
  ${RED}-c rm${RESET} ${YELLOW}<file>${RESET}            Remove config file
  ${RED}-c help${RESET} ${YELLOW}<file>${RESET}          Show config documentation
  ${RED}-c init${RESET}               Initialize configs folder

${BOLD}${BLUE}Collections System${RESET} ${GRAY}(${BLUE}-col${RESET}${GRAY} or ${BLUE}collections${RESET}${GRAY})${RESET}
  ${GRAY}Share and update script collections from Git repositories with version tracking,${RESET}
  ${GRAY}conflict resolution, and modification detection via SHA256 hashes.${RESET}

  ${BLUE}-col${RESET}                Interactive collection browser (browse and import resources)
  ${BLUE}-col init${RESET}           Initialize collection structure (for authors creating collections)
  ${BLUE}-col add${RESET} ${YELLOW}<url>${RESET}      Install collection from GitHub (clone, import resources, track version)
  ${BLUE}-col list${RESET}           List installed collections with versions and imported resources
  ${BLUE}-col sync${RESET}           Check all collections for available updates (fetch latest tags)
  ${BLUE}-col update${RESET} ${YELLOW}[name]${RESET}  Update collection (interactive selection if no name given)
  ${BLUE}-col remove${RESET} ${YELLOW}<name>${RESET}  Remove collection tracking (keeps imported files)
  ${BLUE}-col --help${RESET}         Show detailed collections help with workflows and examples

${BOLD}Environment Variables${RESET}
  ${YELLOW}EDITOR${RESET}            Command to open editor (default: auto-detect)
EOF
  exit 0
  ;;
*)
  if [[ -n "${1:-}" ]]; then
    _load_scripts_module
    run_script "$@"
  else
    echo "Error: No command provided" >&2
    echo "Run 'dr --help' for usage information" >&2
    exit 1
  fi
  ;;
esac
